<html>
<head>
<title>
</title>
  <style>
    #container {
      width: 900px;
      height: 600px;
    }
  </style>
</head>
<body>
<div id="container" oncontextmenu="return false"></div>
<script src="./js/phaser.min.js"></script>
<script>

var game = new Phaser.Game(900, 600, Phaser.AUTO, 'container', { preload: preload, create: create, update: update });

WebFontConfig = {

  //  'active' means all requested fonts have finished loading
  //  We set a 1 second delay before calling 'createText'.
  //  For some reason if we don't the browser cannot render the text the first time it's created.
  active: function() { game.time.events.add(Phaser.Timer.SECOND / 2, createText, this); },

  //  The Google Fonts we want to load (specify as many as you like in the array)
  google: {
    families: ['VT323']
  }

};

function preload() {
  game.load.spritesheet('tile', 'assets/tiles.png', 10, 10, 14);

  //  Load the Google WebFont Loader script
  game.load.script('webfont', '//ajax.googleapis.com/ajax/libs/webfont/1.4.7/webfont.js');
}

var MODES = {
  TEST: { width: 9, height: 9, mineCount: 3 },
  BEGINNER: { width: 9, height: 9, mineCount: 10 },
  INTERMEDIATE: { width: 16, height: 16, mineCount: 40 },
  ADVANCED: { width: 30, height: 16, mineCount: 99 },
};

var mode = MODES.TEST;
var width = mode.width;
var height = mode.height;
var mineCount = mode.mineCount;
var mineMap;
var tileScale = 3;
var firstClick = true;
var previousClickTime = 0;
var previousClickTile = null;
var tileGroup;
var knownCount;
var flaggedCount;
var gameStartTimestamp;
var gameOver = false;

var textTimeElapsed;
var textMinesLeft;

var FRAME = {
  KNOWN: 0,
  UNKNOWN: 1,
  FLAG: 2,
  MINE: 3
};

function createText() {
  var style = { font: "28px VT323", fill: "#FF0000", tabs: [ 150, 150, 200 ] };

  textTimeElapsed = game.add.text(300, 30, 0, style);
  //textTimeElapsed.setShadow(-3, 3, 'rgba(0,0,0,0.5)', 0);

  textMinesLeft = game.add.text(550, 30, 0, style);
  //textMinesLeft.setShadow(-3, 3, 'rgba(0,0,0,0.5)', 0);
}

function create() {
  game.stage.backgroundColor = '#e8e8e8';
  tileGroup = game.add.group();
  mineMap = genEmptyMineMap(width, height);
  knownCount = 0;
  flaggedCount = 0;
  gameOver = false;

  for (var i = 0; i < height; i++) {
    for (var j = 0; j < width; j++) {
      var onClickHandler = (function() {
        var tile = mineMap[i][j];

        return function(sprite, pointer) {
          curClickTime = this.input.mouse.event.timeStamp;

          var doubleClicked = false;
          if (curClickTime - previousClickTime < 500 && previousClickTile == sprite) {
            doubleClicked = true;
          }
            
          previousClickTime = curClickTime;
          previousClickTile = sprite;
          frame = getFrame(tile);

          if (firstClick) {
            firstClick = false;
            mineMap = populateMineMap(mineMap, mineCount, tile.x, tile.y);
            tile.sprite.frame = FRAME.KNOWN;
            expandTile(tile.x, tile.y, mineMap);
          } else if (tile.known) {
            if (doubleClicked) {
              var neighborFlagCount = getNeighborFlagCount(tile.x, tile.y);
              if (neighborFlagCount == tile.neighborMineCount) {
                try {
                  expandTile(tile.x, tile.y, mineMap);
                } catch (e) {
                  revealAll();
                }
              }
            }
          } else if (this.input.mouse.event.button === Phaser.Mouse.RIGHT_BUTTON) {
            if (tile.sprite.frame == FRAME.FLAG) {
              tile.unflag();
            } else {
              tile.flag();
            }
          } else if (tile.sprite.frame == FRAME.FLAG) {
            // pass
          } else if (tile.mine) {
            revealAll();
          } else {
            if (tile.neighborMineCount == 0) {
              if (!tile.known) {
                tile.sprite.frame = frame;
                expandTile(tile.x, tile.y, mineMap);
              }
            } else {
              tile.makeKnown();
              tile.sprite.frame = frame;
            }
          }
        }
      })();

      var tileSprite = tileGroup.create(j*10*tileScale, i*10*tileScale, 'tile', FRAME.UNKNOWN);
      tileSprite.frame = FRAME.UNKNOWN;
      tileSprite.scale.setTo(tileScale, tileScale);
      tileSprite.inputEnabled = true;
      tileSprite.events.onInputDown.add(onClickHandler, this);
      mineMap[i][j].sprite = tileSprite;
    }
  }

  var xOffset = (game.width - width*tileScale*10)/2;
  tileGroup.x = xOffset;
  tileGroup.y = 120;
}

function revealAll() {
  for (var i = 0; i < height; i++) {
    for (var j = 0; j < width; j++) {
      var tile = mineMap[i][j];
      if (!tile.known) {
        tile.makeKnown();
        tile.sprite.frame = getFrame(tile);
      }
    }
  }
}

function getFrame(tile) {
  if (tile.mine) {
    return FRAME.MINE;
  } else if (tile.neighborMineCount == 0) {
    return FRAME.KNOWN;
  } else {
    return tile.neighborMineCount+3;
  }
}

function update() {
  if (gameOver) return;

  if (textTimeElapsed) {
    textTimeElapsed.text = Math.floor(((new Date()).getTime() - gameStartTimestamp) / 1000) || 0;
    textMinesLeft.text = mineCount - flaggedCount;
  }
}

function genEmptyMineMap(width, height) {
  var map = [];
  for (var i = 0; i < height; i++) {
    map.push([]);
    for (var j = 0; j < width; j++) {
      map[i].push({ 
        x: j,
        y: i,
        mine: true,
        neighborMineCount: 0,
        known: false,
        makeKnown: function() {
          if (this.known) return;

          this.known = true;
          knownCount++;

          if (knownCount >= width*height-mineCount) {
            gameOver = true;
            console.log('won in ', ((new Date()).getTime() - gameStartTimestamp) / 1000, ' seconds');
          }
        },
        flag: function() {
          if (this.sprite.frame == FRAME.FLAG) return;
          this.sprite.frame = FRAME.FLAG;
          flaggedCount++;
        },
        unflag: function() {
          if (this.sprite.frame != FRAME.FLAG) return;
          this.sprite.frame = FRAME.UNKNOWN;
          flaggedCount--;
        }
      });
    }
  }

  return map;
}

function populateMineMap(emptyMap, mineCount, initialClickX, initialClickY) {
  var map = emptyMap;
  var width = map[0].length;
  var height = map.length;
  gameStartTimestamp = (new Date()).getTime();

  var minesPositions = [];
  for (var i = 0; i < height; i++) {
    for (var j = 0; j < width; j++) {
      minesPositions.push([j, i]);
    }
  }

  // using strictly decreasing order so we can easily remove item from minesPositions
  for (var dy = 1; dy >= -1; dy--) {
    for (var dx = 1; dx >= -1; dx--) {
      var x = initialClickX+dx;
      var y = initialClickY+dy;

      if (x >= 0 && x < width && y >= 0 && y < height) {
        map[y][x].mine = false;
        minesPositions.splice(y*width+x, 1);
      }
    }
  }

  // shuffle the positions
  var minesToUncheckCount = minesPositions.length - mineCount;
  var minesToUncheck = getNRandomItems(minesPositions, minesToUncheckCount);

  for (var i = 0; i < minesToUncheck.length; i++) {
    var x = minesToUncheck[i][0];
    var y = minesToUncheck[i][1];
    map[y][x].mine = false;
  }

  for (var i = 0; i < height; i++) {
    for (var j = 0; j < width; j++) {
      if (map[i][j].mine) {
        for (var dx = -1; dx <= 1; dx++) {
          for (var dy = -1; dy <= 1; dy++) {
            var x = j+dx;
            var y = i+dy;

            if (!(dx == 0 && dy == 0) && x >= 0 && x < width && y >= 0 && y < height) {
              map[y][x].neighborMineCount++;
            }
          }
        }
      }
    }
  }

  return map;
}

function getNRandomItems(items, n) {
  var bucket = [];

  for (var i = 0; i < n; i++) {
    var rndIdx = i + Math.floor(Math.random()*(items.length-i));
    bucket.push(items[rndIdx]);
    items[rndIdx] = items[i];
  }

  return bucket;
}

function expandTile(x, y, mineMap) {
  var tile = mineMap[y][x];
  tile.makeKnown();

  for (var dx = -1; dx <= 1; dx++) {
    for (var dy = -1; dy <= 1; dy++) {
      if (!(dx == 0 && dy == 0) && x+dx >= 0 && x+dx < width && y+dy >= 0 && y+dy < height) {
        var t = mineMap[y+dy][x+dx];
        if (!t.known && t.sprite.frame != FRAME.FLAG) {
          if (t.mine) {
            throw 'Boom!';
          }

          var frame = getFrame(t);
          t.sprite.frame = frame;
          t.makeKnown();
          if (t.neighborMineCount == 0) {
            expandTile(x+dx, y+dy, mineMap);
          }
        }
      }
    }
  }
}

function getNeighborFlagCount(x0, y0) {
  var flagCount = 0;

  for (var dx = -1; dx <= 1; dx++) {
    for (var dy = -1; dy <= 1; dy++) {
      var x = x0+dx;
      var y = y0+dy;

      if (x >= 0 && x < width && y >= 0 && y < height && mineMap[y][x].sprite.frame == FRAME.FLAG) {
        flagCount++;
      }
    }
  }

  return flagCount;
}
</script>
</body>
</html>
