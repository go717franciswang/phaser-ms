<html>
<head>
<title>
</title>
  <style>
    #container {
      width: 800px;
      height: 600px;
    }
  </style>
</head>
<body>
<div id="container" oncontextmenu="return false"></div>
<script src="./js/phaser.min.js"></script>
<script>

var game = new Phaser.Game(800, 600, Phaser.AUTO, 'container', { preload: preload, create: create, update: update });

function preload() {
  game.load.spritesheet('tile', 'assets/tiles.png', 10, 10, 14);
}

var width = 10;
var height = 10;
var mineCount = 10;
var mineMap;
var tileScale = 3;
var firstClick = true;
var previousClickTime = 0;
var previousClickTile = null;

var FRAME = {
  KNOWN: 0,
  UNKNOWN: 1,
  FLAG: 2,
  MINE: 3
};

function create() {
  game.stage.backgroundColor = '#e8e8e8';
  mineMap = genEmptyMineMap(width, height);
  for (var i = 0; i < height; i++) {
    for (var j = 0; j < width; j++) {
      var onClickHandler = (function() {
        var tile = mineMap[i][j];

        return function(sprite, pointer) {
          curClickTime = this.input.mouse.event.timeStamp;

          var doubleClicked = false;
          if (curClickTime - previousClickTime < 500 && previousClickTile == sprite) {
            doubleClicked = true;
          }
            
          previousClickTime = curClickTime;
          previousClickTile = sprite;
          frame = getFrame(tile);

          if (firstClick) {
            firstClick = false;
            mineMap = populateMineMap(mineMap, mineCount, tile.x, tile.y);
            tile.sprite.frame = FRAME.KNOWN;
            expandTile(tile.x, tile.y, mineMap);
          } else if (tile.known) {
            if (doubleClicked) {
              var neighborFlagCount = getNeighborFlagCount(tile.x, tile.y);
              if (neighborFlagCount == tile.neighborMineCount) {
                try {
                  expandTile(tile.x, tile.y, mineMap);
                } catch (e) {
                  revealAll();
                }
              }
            }
          } else if (this.input.mouse.event.button === Phaser.Mouse.RIGHT_BUTTON) {
            if (tile.sprite.frame == FRAME.FLAG) {
              tile.sprite.frame = FRAME.UNKNOWN;
            } else {
              tile.sprite.frame = FRAME.FLAG;
            }
          } else if (tile.sprite.frame == FRAME.FLAG) {
            // pass
          } else if (tile.mine) {
            revealAll();
          } else {
            if (tile.neighborMineCount == 0) {
              if (!tile.known) {
                tile.sprite.frame = frame;
                expandTile(tile.x, tile.y, mineMap);
              }
            } else {
              tile.known = true;
              tile.sprite.frame = frame;
            }
          }
        }
      })();

      var tileSprite = game.add.sprite(i*10*tileScale, j*10*tileScale, 'tile', 1);
      tileSprite.frame = FRAME.UNKNOWN;
      tileSprite.scale.setTo(tileScale, tileScale);
      tileSprite.inputEnabled = true;
      tileSprite.events.onInputDown.add(onClickHandler, this);
      mineMap[i][j].sprite = tileSprite;
    }
  }
}

function revealAll() {
  for (var i = 0; i < height; i++) {
    for (var j = 0; j < width; j++) {
      var tile = mineMap[i][j];
      if (!tile.known) {
        tile.known = true;
        tile.sprite.frame = getFrame(tile);
      }
    }
  }
}

function getFrame(tile) {
  if (tile.mine) {
    return FRAME.MINE;
  } else if (tile.neighborMineCount == 0) {
    return FRAME.KNOWN;
  } else {
    return tile.neighborMineCount+3;
  }
}

function update() {
}

function genEmptyMineMap(width, height) {
  var map = [];
  for (var i = 0; i < height; i++) {
    map.push([]);
    for (var j = 0; j < width; j++) {
      map[i].push({ 
        x: j,
        y: i,
        mine: true,
        neighborMineCount: 0,
        known: false
      });
    }
  }

  return map;
}

function populateMineMap(emptyMap, mineCount, initialClickX, initialClickY) {
  var map = emptyMap;
  var width = map[0].length;
  var height = map.length;

  var minesPositions = [];
  for (var i = 0; i < height; i++) {
    for (var j = 0; j < width; j++) {
      minesPositions.push([j, i]);
    }
  }

  // using strictly decreasing order so we can easily remove item from minesPositions
  for (var dy = 1; dy >= -1; dy--) {
    for (var dx = 1; dx >= -1; dx--) {
      var x = initialClickX+dx;
      var y = initialClickY+dy;

      if (x >= 0 && x < width && y >= 0 && y < height) {
        map[y][x].mine = false;
        minesPositions.splice(y*width+x, 1);
      }
    }
  }

  // shuffle the positions
  var minesToUncheckCount = minesPositions.length - mineCount;
  var minesToUncheck = getNRandomItems(minesPositions, minesToUncheckCount);

  for (var i = 0; i < minesToUncheck.length; i++) {
    var x = minesToUncheck[i][0];
    var y = minesToUncheck[i][1];
    map[y][x].mine = false;
  }

  for (var i = 0; i < height; i++) {
    for (var j = 0; j < width; j++) {
      if (map[i][j].mine) {
        for (var dx = -1; dx <= 1; dx++) {
          for (var dy = -1; dy <= 1; dy++) {
            var x = j+dx;
            var y = i+dy;

            if (!(dx == 0 && dy == 0) && x >= 0 && x < width && y >= 0 && y < height) {
              map[y][x].neighborMineCount++;
            }
          }
        }
      }
    }
  }

  return map;
}

function getNRandomItems(items, n) {
  var bucket = [];

  for (var i = 0; i < n; i++) {
    var rndIdx = i + Math.floor(Math.random()*(items.length-i));
    bucket.push(items[rndIdx]);
    items[rndIdx] = items[i];
  }

  return bucket;
}

function expandTile(x, y, mineMap) {
  var tile = mineMap[y][x];
  tile.known = true;

  for (var dx = -1; dx <= 1; dx++) {
    for (var dy = -1; dy <= 1; dy++) {
      if (!(dx == 0 && dy == 0) && x+dx >= 0 && x+dx < width && y+dy >= 0 && y+dy < height) {
        var t = mineMap[y+dy][x+dx];
        if (!t.known && t.sprite.frame != FRAME.FLAG) {
          if (t.mine) {
            throw 'Boom!';
          }

          var frame = getFrame(t);
          t.sprite.frame = frame;
          t.known = true;
          if (t.neighborMineCount == 0) {
            expandTile(x+dx, y+dy, mineMap);
          }
        }
      }
    }
  }
}

function getNeighborFlagCount(x0, y0) {
  var flagCount = 0;

  for (var dx = -1; dx <= 1; dx++) {
    for (var dy = -1; dy <= 1; dy++) {
      var x = x0+dx;
      var y = y0+dy;

      if (x >= 0 && x < width && y >= 0 && y < height && mineMap[y][x].sprite.frame == FRAME.FLAG) {
        flagCount++;
      }
    }
  }

  return flagCount;
}
</script>
</body>
</html>
